#summary Quality Assurance Plan

= Testing Report =

Testing for the Final release consisted of three parts:

== Unit Testing ==

The low-level data types were checked for consistency, and each method was verified to return the expected results and make state changes to the objects as expected. The test cases are as follows:

|| *Filename* || *Components Tested* ||
|| !AccountDataTest.java || data consistency, adding friends, removing friends, searching for friends ||
|| !AccountTempDataTest.java || data consistency ||
|| !ChatbotTest || response generation, response triggering, enabler ||
|| !ChatlogMessageTempDataTest || data consistency ||
|| !ConversationDataTest || data consistency, message retrieval, message formatting, message storage ||
|| !CurrentProfileDataTest || data consistency, adding accounts, removing friends, getting friend list ||
|| !GoogleTalkUserData || data consistency ||
|| !JabberUserData || data consistency ||
|| !TwitterUserData || data consistency ||
|| !MessageDataTest || data consistency, message manipulation, message retrieval ||
|| !ServerTypeTest || utility methods for enumerated type ||
|| !UserDataTest || inheritance test, data consistency ||

*Results:*

Development of unit test cases allowed us to remove redundant code and add more robust methods to our low-level data. For instance, the Quality Assurance team identified methods that effectively did the same task, and merged them into one. 

Another important find was that the search functions were comparing based on an equals method inherited by the Object class. Essentially, two !UserData or !AccountData objects were treated as equal only if they had the same reference; not if their data was equal. This posed subtle problems for removing or checking for the existence of these objects. As The equals() method was overridden as a result of the test cases.

Furthermore, these tests will be conducted and updated as our low-level data types under go upgrades in future revisions of the program.

All the test cases have successfully passed the test. We have tested most of the code using JUnit but some of the code wasn't tested or the test isn't completed and I include the reason for each one:

*DatabaseFunctions:* We had problems testing it by JUnit, and we couldn't figure out the reason. So, we included database testing in the integration test phase.

*GUI, sounds, Spell checker and Dictionary:* It's more difficult to test those classes using unit testing. So, we tested this by integration and manual testing.

== Reports from JUnit test cases  ==

Here are three examples for result from JUnit testing:

[http://parrot-im.googlecode.com/files/Untitled.jpg]

[http://parrot-im.googlecode.com/files/Untitled2.jpg]

[http://parrot-im.googlecode.com/files/Untitled3.jpg]


The green line and green labels on the methods mean that methods,(or when also the test case are labeled green) are successful and no errors have occured according to test case alogrithms. If the test case are labeled blue this means there were an error according to test case (mostly logical) for example in our DatabasefunctionsTest class, it gives failure to some functions eventhough it works in practice (that's why we didn't fully implemented DatabaseFunctionsTest). When methods are labeled red, this means that there were an error in processing the function itself (syntax error, initialization error) and complier stops the testing for the method in this case. 

== Integration Testing ==

We employed two main integration steps to test Parrot IM. First, we integrated the Database and the Model, and checked both for consistencies while accessing and mutating data. Next, we integrated the Controller class, and performed a functional test which in turn integrated the lower-level components of the system, namely the Model and the Database.

  * !ModelToDatabaseTest.java
    * Checks for consistency between the model and the database. The only location in which the database can be called is the model. We mainly checked for consistency in dealing with duplicate input.
  * MainController.java
    * Executes functions to mimic user interaction with Parrot IM. All calls come from the this main controller class, which currently only supports XMPP and Twitter functions. The Model and Database are, again, involved in processing the requests. The integrity of both are checked also.

*Results:*
Integration testing was useful in organizing and cleaning up the code. In designing, it was not completely clear which components of the program handled certain things. For instance, is it the controller, model, or database's job to deal with duplicate account additions? Is it all of them? Integration testing showed errors when we didn't handle these situations properly. Ultimately, the testing made us set a focus to handle data integrity, the Model.

In this phase, we tried to make sure that everything works well in practice. This includes testing the following:

1. All the features are working properly without any errors or crashing.

2. Database retuns correct data.

3. Consistent GUI for easy-to-use interface.

We acheived the testing by following a simple tasks that users normally do. We put a table that include the procedures, observations on testing the task, and the expected output based on our features document:

|| *Task* || *Observation* || *Expected result* ||
|| Signing in || It takes around 10 seconds to login. || Users are able to sign in within 8 seconds on any computer of a Pentium 4 class or higher, or around 1 GHz of CPU capability.||
|| Signing out || Program signs out all users within 1 second. || Users are able to sign out within 1 second.||
|| Signing out, Signing in again || Users are able to flexibly sign-in and sign-out at any time. || Users are able to sign in and out multiple times. ||
|| Adding a buddy|| Users are able to add a buddy within 3 seconds. || When adding a buddy, it takes 3 seconds. ||
|| Removing a buddy|| Users are able to removea user within 2 seconds. || Users have no problem removing a buddy, and the buddy will be removed from the database. ||
|| Blocking a buddy|| Users can organize the list of blocked buddies by blocking a buddy within 2 seconds.|| Users are able to see the blocked buddies both in the buddy list and the blocked manager.  || 
|| Unblocking a buddy|| Users are able to unblock a buddy within 2 seconds.||  Users are able to unblock a buddythrough the buddy list and the blocked manager. ||
|| Viewing Chat log || Shows the previous chat history organized by users' account. || You can view chatlog, and search conversations. ||
|| Connected buddies|| Inconsistent number of connected buddies. || Number of connected buddiesshould be displayed consistently. ||
|| Changing a personal status|| Users are able to change their states effectively. || Users are able to change their states both in the buddylist and the option.||
|| Changing a personal avator picture || Users are able to change their avatar pictures effectively||  Users are able to change their avatar pictures both in the buddylist and the option.||
|| Chating with a friend || Users are able to chat flexibly with a buddy. ||  Users are able to chat flexibly with a buddy in a chat or conference room. ||
|| Pressing Enter to send || Sending a message by pressing Enter takes no more than 1 second to process. ||  Users are able to send a message instantly. ||


== User Acceptance Testing ==

User Acceptance testing for the final version was a week-long test. The procedures and results are as follows:
  * [UserAcceptanceTest Testing procedures]
  * [UserAcceptanceReports Reports]